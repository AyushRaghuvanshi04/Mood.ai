import { NextResponse } from "next/server";
import { GoogleGenerativeAI } from "@google/generative-ai";

// Function to search for songs on Spotify using web search
async function verifySongOnSpotify(title: string, artist: string): Promise<{ exists: boolean; spotifyId?: string; verifiedTitle?: string; verifiedArtist?: string }> {
	try {
		// Use web search to check if song exists on Spotify
		const searchQuery = `"${title}" "${artist}" site:open.spotify.com`;
		const searchUrl = `https://www.googleapis.com/customsearch/v1?key=${process.env.GOOGLE_SEARCH_API_KEY}&cx=${process.env.GOOGLE_SEARCH_ENGINE_ID}&q=${encodeURIComponent(searchQuery)}`;
		
		const response = await fetch(searchUrl);
		const data = await response.json();
		
		if (data.items && data.items.length > 0) {
			// Extract Spotify ID from the URL
			const spotifyUrl = data.items[0].link;
			const spotifyIdMatch = spotifyUrl.match(/track\/([a-zA-Z0-9]+)/);
			
			if (spotifyIdMatch) {
				return {
					exists: true,
					spotifyId: spotifyIdMatch[1],
					verifiedTitle: title,
					verifiedArtist: artist
				};
			}
		}
		
		// If not found, try alternative search without site restriction
		const altSearchQuery = `"${title}" "${artist}" spotify`;
		const altSearchUrl = `https://www.googleapis.com/customsearch/v1?key=${process.env.GOOGLE_SEARCH_API_KEY}&cx=${process.env.GOOGLE_SEARCH_ENGINE_ID}&q=${encodeURIComponent(altSearchQuery)}`;
		
		const altResponse = await fetch(altSearchUrl);
		const altData = await altResponse.json();
		
		if (altData.items && altData.items.length > 0) {
			// Look for Spotify links in the results
			for (const item of altData.items) {
				if (item.link.includes('open.spotify.com/track/')) {
					const spotifyIdMatch = item.link.match(/track\/([a-zA-Z0-9]+)/);
					if (spotifyIdMatch) {
						return {
							exists: true,
							spotifyId: spotifyIdMatch[1],
							verifiedTitle: title,
							verifiedArtist: artist
						};
					}
				}
			}
		}
		
		return { exists: false };
	} catch (error) {
		console.error('Error verifying song on Spotify:', error);
		return { exists: false };
	}
}

// Function to verify multiple songs and return only valid ones
async function verifySongsOnSpotify(tracks: Array<{title: string, artist: string}>): Promise<Array<{title: string, artist: string, spotifyId?: string}>> {
	const verifiedTracks = [];
	
	for (const track of tracks) {
		const verification = await verifySongOnSpotify(track.title, track.artist);
		if (verification.exists) {
			verifiedTracks.push({
				title: verification.verifiedTitle || track.title,
				artist: verification.verifiedArtist || track.artist,
				spotifyId: verification.spotifyId
			});
		}
	}
	
	return verifiedTracks;
}

async function buildMock(body: any) {
	const {
		prompt = "",
		title = "My Mood.ai Playlist",
		description = "Generated by Mood.ai",
		numSongs = 15,
		isPublic = true,
		language = "",
		genre = "",
		timePeriod = "",
	} = body || {};
	
	// Create realistic song suggestions based on the prompt
	const promptLower = prompt.toLowerCase();
	let tracks = [];
	
	if (promptLower.includes('love') || promptLower.includes('romantic') || promptLower.includes('first love') || promptLower.includes('kind of songs')) {
		tracks = [
			{ title: "All of Me", artist: "John Legend" },
			{ title: "Perfect", artist: "Ed Sheeran" },
			{ title: "Thinking Out Loud", artist: "Ed Sheeran" },
			{ title: "A Thousand Years", artist: "Christina Perri" },
			{ title: "At Last", artist: "Etta James" },
			{ title: "Make You Feel My Love", artist: "Adele" },
			{ title: "The Way You Look Tonight", artist: "Frank Sinatra" },
			{ title: "Can't Help Myself", artist: "Four Tops" },
			{ title: "Unchained Melody", artist: "The Righteous Brothers" },
			{ title: "Something", artist: "The Beatles" },
			{ title: "Your Song", artist: "Elton John" },
			{ title: "I Will Always Love You", artist: "Whitney Houston" },
			{ title: "Just the Way You Are", artist: "Bruno Mars" },
			{ title: "Stay With Me", artist: "Sam Smith" },
			{ title: "All I Ask", artist: "Adele" }
		];
	} else if (promptLower.includes('gym') || promptLower.includes('workout') || promptLower.includes('fitness')) {
		tracks = [
			{ title: "Eye of the Tiger", artist: "Survivor" },
			{ title: "Stronger", artist: "Kanye West" },
			{ title: "Till I Collapse", artist: "Eminem" },
			{ title: "Can't Stop", artist: "Red Hot Chili Peppers" },
			{ title: "Lose Yourself", artist: "Eminem" },
			{ title: "Thunderstruck", artist: "AC/DC" },
			{ title: "We Will Rock You", artist: "Queen" },
			{ title: "Don't Stop Me Now", artist: "Queen" },
			{ title: "The Final Countdown", artist: "Europe" },
			{ title: "Push It", artist: "Salt-N-Pepa" },
			{ title: "Pump It", artist: "The Black Eyed Peas" },
			{ title: "Work Bitch", artist: "Britney Spears" },
			{ title: "Stronger (What Doesn't Kill You)", artist: "Kelly Clarkson" },
			{ title: "Fight Song", artist: "Rachel Platten" },
			{ title: "Roar", artist: "Katy Perry" }
		];
	} else if (promptLower.includes('chill') || promptLower.includes('relax') || promptLower.includes('study')) {
		tracks = [
			{ title: "Sunflower", artist: "Post Malone" },
			{ title: "Blinding Lights", artist: "The Weeknd" },
			{ title: "Circles", artist: "Post Malone" },
			{ title: "Watermelon Sugar", artist: "Harry Styles" },
			{ title: "Levitating", artist: "Dua Lipa" },
			{ title: "Good 4 U", artist: "Olivia Rodrigo" },
			{ title: "Stay", artist: "The Kid LAROI & Justin Bieber" },
			{ title: "Heat Waves", artist: "Glass Animals" },
			{ title: "Peaches", artist: "Justin Bieber" },
			{ title: "Industry Baby", artist: "Lil Nas X" },
			{ title: "Montero", artist: "Lil Nas X" },
			{ title: "Kiss Me More", artist: "Doja Cat" },
			{ title: "Positions", artist: "Ariana Grande" },
			{ title: "Dynamite", artist: "BTS" },
			{ title: "Butter", artist: "BTS" }
		];
	} else if (promptLower.includes('party') || promptLower.includes('dance') || promptLower.includes('club')) {
		tracks = [
			{ title: "Uptown Funk", artist: "Mark Ronson ft. Bruno Mars" },
			{ title: "24K Magic", artist: "Bruno Mars" },
			{ title: "Shape of You", artist: "Ed Sheeran" },
			{ title: "Despacito", artist: "Luis Fonsi ft. Daddy Yankee" },
			{ title: "Closer", artist: "The Chainsmokers ft. Halsey" },
			{ title: "Cheap Thrills", artist: "Sia" },
			{ title: "Can't Stop the Feeling!", artist: "Justin Timberlake" },
			{ title: "Shake It Off", artist: "Taylor Swift" },
			{ title: "Get Lucky", artist: "Daft Punk ft. Pharrell Williams" },
			{ title: "Happy", artist: "Pharrell Williams" },
			{ title: "Timber", artist: "Pitbull ft. Ke$ha" },
			{ title: "Turn Down for What", artist: "DJ Snake & Lil Jon" },
			{ title: "Fancy", artist: "Iggy Azalea ft. Charli XCX" },
			{ title: "Problem", artist: "Ariana Grande ft. Iggy Azalea" },
			{ title: "Worth It", artist: "Fifth Harmony ft. Kid Ink" }
		];
	} else {
		// Default popular songs
		tracks = [
			{ title: "Blinding Lights", artist: "The Weeknd" },
			{ title: "Watermelon Sugar", artist: "Harry Styles" },
			{ title: "Levitating", artist: "Dua Lipa" },
			{ title: "Good 4 U", artist: "Olivia Rodrigo" },
			{ title: "Stay", artist: "The Kid LAROI & Justin Bieber" },
			{ title: "Heat Waves", artist: "Glass Animals" },
			{ title: "Peaches", artist: "Justin Bieber" },
			{ title: "Industry Baby", artist: "Lil Nas X" },
			{ title: "Montero", artist: "Lil Nas X" },
			{ title: "Kiss Me More", artist: "Doja Cat" },
			{ title: "Positions", artist: "Ariana Grande" },
			{ title: "Dynamite", artist: "BTS" },
			{ title: "Butter", artist: "BTS" },
			{ title: "Sunflower", artist: "Post Malone" },
			{ title: "Circles", artist: "Post Malone" }
		];
	}
	
	// Take only the requested number of songs
	const numTracks = Math.max(1, Math.min(50, Number(numSongs) || 15));
	const selectedTracks = tracks.slice(0, numTracks);
	
	// Verify songs on Spotify if API keys are available
	let verifiedTracks = selectedTracks;
	if (process.env.GOOGLE_SEARCH_API_KEY && process.env.GOOGLE_SEARCH_ENGINE_ID) {
		console.log('Verifying songs on Spotify...');
		verifiedTracks = await verifySongsOnSpotify(selectedTracks);
		console.log(`Verified ${verifiedTracks.length} out of ${selectedTracks.length} songs`);
	}
	
	// If verification removed too many songs, add some back from the original list
	if (verifiedTracks.length < Math.min(5, numTracks)) {
		console.log('Adding unverified songs to meet minimum requirement');
		const unverifiedTracks = selectedTracks.filter(track => 
			!verifiedTracks.some(vt => vt.title === track.title && vt.artist === track.artist)
		);
		verifiedTracks = [...verifiedTracks, ...unverifiedTracks.slice(0, Math.min(5, numTracks) - verifiedTracks.length)];
	}
	
	const finalTracks = verifiedTracks.map((track, i) => ({
		id: `mock-track-${i + 1}`,
		title: track.title,
		artist: track.artist,
		previewUrl: null,
		spotifyId: track.spotifyId || null,
	}));
	
	return {
		id: "mock-playlist-123",
		name: title,
		description,
		public: Boolean(isPublic),
		imageUrl: "https://picsum.photos/seed/ai-playlist/400/400",
		externalUrl: "https://open.spotify.com/playlist/mock",
		tracks: finalTracks,
		verificationStats: {
			totalGenerated: selectedTracks.length,
			verifiedOnSpotify: verifiedTracks.filter(t => t.spotifyId).length,
			unverified: verifiedTracks.filter(t => !t.spotifyId).length
		}
	};
}

function tryExtractJsonFromText(text: string): any | null {
	// Remove code fences and backticks
	let cleaned = text.replace(/```json|```/gi, "").trim();
	// Try to find first JSON object
	const start = cleaned.indexOf("{");
	const end = cleaned.lastIndexOf("}");
	if (start !== -1 && end !== -1 && end > start) {
		cleaned = cleaned.slice(start, end + 1);
	}
	try {
		return JSON.parse(cleaned);
	} catch {
		return null;
	}
}

export async function POST(req: Request) {
	const body = await req.json().catch(() => ({} as any));

	const geminiKey = process.env.GEMINI_API_KEY;
	if (!geminiKey) {
		return NextResponse.json({ success: true, playlist: await buildMock(body) });
	}

	try {
		const genAI = new GoogleGenerativeAI(geminiKey);
		const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
		const { 
			prompt = "", 
			title = "My Mood.ai Playlist", 
			description = "Generated by Mood.ai", 
			numSongs = 15, 
			isPublic = true,
			language = "",
			genre = "",
			timePeriod = ""
		} = body || {};
		const max = Math.max(1, Math.min(50, Number(numSongs) || 15));

		// Build enhanced prompt with language, genre, and time period
		let enhancedPrompt = `Create a playlist for: ${prompt}`;
		if (language) {
			enhancedPrompt += `\nLanguage/Region: ${language}`;
		}
		if (genre) {
			enhancedPrompt += `\nGenre: ${genre}`;
		}
		if (timePeriod) {
			enhancedPrompt += `\nTime Period: ${timePeriod}`;
		}

		const system = `You are a music curator expert. Generate ${max} real, popular songs that match the given vibe/mood and criteria. Return ONLY a minified JSON object with this exact shape: {"tracks":[{"title":"Song Title","artist":"Artist Name"}]}. Use real, well-known songs and artists that are likely to be available on Spotify. Do not include markdown, code blocks, or extra text.`;
		const resp = await model.generateContent([{ text: system }, { text: enhancedPrompt }]);
		const text = resp.response.text();
		
		console.log("Gemini response:", text);

		let parsed = tryExtractJsonFromText(text);
		let tracks = Array.isArray(parsed?.tracks) ? parsed.tracks : [];

		if (!Array.isArray(tracks) || tracks.length < 1) {
			// Use our improved fallback function
			console.log("Gemini returned invalid data, using improved fallback");
			return NextResponse.json({ success: true, playlist: await buildMock(body) });
		}

		// Verify songs on Spotify
		let verifiedTracks = tracks;
		if (process.env.GOOGLE_SEARCH_API_KEY && process.env.GOOGLE_SEARCH_ENGINE_ID) {
			console.log('Verifying Gemini songs on Spotify...');
			verifiedTracks = await verifySongsOnSpotify(tracks);
			console.log(`Verified ${verifiedTracks.length} out of ${tracks.length} songs`);
		}

		// If verification removed too many songs, add some back from the original list
		if (verifiedTracks.length < Math.min(5, max)) {
			console.log('Adding unverified songs to meet minimum requirement');
			const unverifiedTracks = tracks.filter(track => 
				!verifiedTracks.some(vt => vt.title === track.title && vt.artist === track.artist)
			);
			verifiedTracks = [...verifiedTracks, ...unverifiedTracks.slice(0, Math.min(5, max) - verifiedTracks.length)];
		}

		const playlist = {
			id: "gemini-playlist-123",
			name: title,
			description,
			public: Boolean(isPublic),
			imageUrl: "https://picsum.photos/seed/gemini-playlist/400/400",
			externalUrl: "https://open.spotify.com/playlist/mock",
			tracks: verifiedTracks.slice(0, max).map((t: any, i: number) => ({
				id: `gemini-${i + 1}`,
				title: String(t.title || `Track ${i + 1}`),
				artist: String(t.artist || "Unknown Artist"),
				previewUrl: null,
				spotifyId: t.spotifyId || null,
			})),
			verificationStats: {
				totalGenerated: tracks.length,
				verifiedOnSpotify: verifiedTracks.filter(t => t.spotifyId).length,
				unverified: verifiedTracks.filter(t => !t.spotifyId).length
			}
		};
		return NextResponse.json({ success: true, playlist });
	} catch (err) {
		console.error('Gemini error:', err);
		return NextResponse.json({ success: true, playlist: await buildMock(body), note: "Gemini failed, returned mock" });
	}
}
